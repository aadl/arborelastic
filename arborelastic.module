<?php

use Elasticsearch\ClientBuilder;

/**
 * Display help and module information
 * @return help text for section
 */
function arborelastic_help($path, $arg)
{
  $output = '';
  switch ($path) {
    case "admin/help#arborelastic":
      $output = '<p>' .  t("Custom search with Elasticsearch") . '</p>';
      break;
  }
  return $output;
}
function arborelastic_search($path_id, $query, $args = [])
{
  $hosts = [
    \Drupal::config('arborelastic.settings')->get('arborelastic_host') . ':' .  \Drupal::config('arborelastic.settings')->get('arborelastic_port'),
  ];
  $es_client = ClientBuilder::create()->setHosts($hosts)->build();
  $indexes = \Drupal::config('arborelastic.settings')->get('arborelastic_indexes');
  $indexes = explode("\n", $indexes);
  foreach ($indexes as $i => $index) {
    $parts = explode(':', $index);
    $indexes[$parts[0]] = array('index' => trim($parts[1]));
    unset($indexes[$i]);
  }
  $index = $indexes[$path_id]['index'];
  $formats = [
    'catalog' => [
      'index' => 'bibs',
      'from' => (isset($args['page']) ? $args['page'] : 0) * (isset($args['size']) ? $args['size'] : 25),
      'body' => [
        'size' => isset($args['size']) ? $args['size'] : 25,
        'query' => [
          'function_score' => [
            'query' => [
              'bool' => [
                'should' => [
                  [
                    'match' => [
                      'lang' => [
                        'query' => 'eng',
                        'boost' => 300
                      ]
                    ]
                  ],
                ],
              ]
            ],
            'field_value_factor' => [
              'field' => 'popular_alltime',
              'modifier' => 'log1p',
              'missing' => 1
            ]
          ]
        ],
        'aggs' => [
          'mat_code' => [
            'terms' => [
              'field' => 'mat_code.keyword'
            ]
          ],
          'lang' => [
            'terms' => [
              'field' => 'lang.keyword'
            ]
          ]
        ],
      ]
    ],
    'website' => [
      'index' => 'elasticsearch_index_migration_nodes',
      'from' => (isset($args['page']) ? $args['page'] : 0) * (isset($args['size']) ? $args['size'] : 25),
      'body' => [
        'size' => isset($args['size']) ? $args['size'] : 25,
        'query' => [
          'function_score' => [
            'query' => [
              'bool' => []
            ]
          ]
        ],

      ]
    ],
    'community' => [
      'index' => 'elasticsearch_index_migration_nodes',
      'from' => (isset($args['page']) ? $args['page'] : 0) * (isset($args['size']) ? $args['size'] : 25),
      'body' => [
        'size' => isset($args['size']) ? $args['size'] : 25,
        'query' => [
          'function_score' => [
            'query' => [
              'bool' => []
            ]
          ]
        ],
      ]
    ]
  ];

  $es_query = $formats[$path_id];
  $es_query = applyFilterTerms($es_query, $path_id);
  $es_query = applyQueryTerms($query, $es_query, $path_id);
  $es_query = applyMatchTerms($es_query, $path_id);
  $es_query = applySort($es_query, $path_id);
  // dd(json_encode($es_query['body']));
  try {
    $result = $es_client->search($es_query);
  } catch (\Exception $e) {
    $result = [
      'error' => 'Elasticsearch Query Failed',
      'message' => $e->getMessage(),
    ];
  }
  $result['cur_page'] = $args['page'] ?? 0;
  $result['size'] = $args['size'] ?? 25;

  return $result;
}
function applyQueryTerms($query, $es_query, $path_id)
{
  $search_fields = [
    'author',
    'artist',
    'bib_created',
    'callnum',
    'callnums',
    'lang',
    'pub_year',
    'pub_info',
    'series',
    'subjects',
    'title'
  ];
  $foldables = [
    'title',
    'author',
    'artist'
  ];
  $queryables = [];

  // match all : separated terms and iterate over the resulting key value pairs. Concatenate a query_string for as many as are supplied, checking against folded fields
  preg_match_all('/([a-z]\S*):(["\'\da-z\s].+?(?=(?:[a-z]\S*:|$)))/', $query, $matches);
  $keys = $matches[1];
  $values = $matches[2];

  // place terms into array to then iterate over again to check for operators. Doing this separately is less efficient but easier to handle.
  foreach ($keys as $i => $k) {
    if (in_array($k, $search_fields)) {
      if (in_array($k, $foldables)) {
        $queryables[] = $k . '.folded:(' . trim($values[$i]) . ')';;
      } else {
        $queryables[] = $k . ':(' . trim($values[$i]) . ')';
      }
    }
  }

  foreach ($queryables as $i => $q) {
    if (strpos($q, ' OR)')) {
      $queryables[$i] = str_replace(' OR)', ')', $q) . ' OR ';
    } elseif (strpos($q, ' AND)')) {
      $queryables[$i] = str_replace(' AND)', ')', $q) . ' AND ';
    }
  }

  // if there are no set terms, check for quotation search and set query_string with string escapes
  if (count($queryables) === 0 && strpos($query, '"')) {
    $search_escapes = [',', '-'];
    $search_replace = ['', ' '];
    $query = str_replace($search_escapes, $search_replace, $query);
    $es_query['body']['query']['function_score']['query']['bool']['must'][] =
      [
        'query_string' =>
        [
          "query" => $query,
          "default_operator" => "and",
          "fuzzy_prefix_length" => 3,
          "fuzziness" => 1
        ]
      ];
  } else if (count($queryables) === 0 && $query === '*') {
    $es_query['body']['query']['function_score']['query']['bool']['must'][] =
      [
        'query_string' => [
          "query" => $query,
          "default_operator" => "and",
          "fuzzy_prefix_length" => 3,
          "fuzziness" => 1
        ]
      ];
  } else if (count($queryables) > 0) {
    // set query_string using the terms set above if there are any
    $queryString = '';
    foreach ($queryables as $q) {
      $queryString .= $q;
    }
    $es_query['body']['query']['function_score']['query']['bool']['must'][] =
      [
        'query_string' => [
          "query" => $queryString,
          "default_operator" => "and",
          "fuzzy_prefix_length" => 3,
          "fuzziness" => 1
        ]
      ];
  } else {
    // if no terms or quotation wrapped searches, use a more inclusive search approach. For catalog, queries with 2 words or less currently require all words to be present in the fields. 90% match is used for lonnger queries. Website and community have not been changed. They're large and unwieldy enough datasets that query strings still remain useful.
    $formats = [
      'catalog' => [
        'multi_match' => [
          "query" => $query,
          "fields" => ['title.folded^20', 'author.folded^10', 'artist.folded^10', 'callnum', 'callnums', 'subjects', 'series', 'addl_author', 'addl_title', 'title_medium'],
          "minimum_should_match" => "2<90%"
        ]
      ],
      'website' => [
        "query_string" => [
          "query" => $query,
          "fields" => [
            "*",
          ],
          "default_operator" => "and",
          "fuzzy_prefix_length" => 3,
          "fuzziness" => 1
        ]
      ],
      'community' => [
        "query_string" => [
          "query" => $query,
          "fields" => [
            "*",
          ],
          "default_operator" => "and",
          "fuzzy_prefix_length" => 3,
          "fuzziness" => 1
        ]
      ]
    ];
    $es_query['body']['query']['function_score']['query']['bool']['must'][] = $formats[$path_id];
  }
  return $es_query;
}
function applyMatchTerms($es_query, $path_id)
{
  $args = $_GET;

  $matchables = [
    'catalog' => [
      'available_branches' => ['type' => 'term'],
      'mat_code' => ['type' => 'terms'],
      'lang' => ['type' => 'term'],
      'nonfiction' => ['type' => 'term'],
      'ages' => ['type' => 'term'],
    ],
    'community' => [
      'old_news_taxonomy' => ['type' => 'terms'],
      'mat_code' => ['type' => 'terms', 'keyword' => true],
      'oldnews_date' => [
        'type' => 'range',
      ],
      'photo_indexed' => [
        'type' => 'term'
      ]
    ],
    'website' => [
      'mat_code' => ['type' => 'terms', 'keyword' => true],
      'location_name' => ['type' => 'term'],
      'event_ages' => ['type' => 'term'],
      'event_categories' => ['type' => 'term'],
    ]
  ];
  foreach ($args as $k => $v) {
    if (!array_key_exists($k, $matchables[$path_id])) {
      continue;
    }
    $es_query['body']['query']['function_score']['query']['bool']['must'][] = scaffoldQuery($matchables[$path_id][$k], $k, $v);
  }
  return $es_query;
}
function applyFilterTerms($es_query, $path_id)
{
  $defaults = [
    'catalog' => [
      'active' => [
        'type' => 'match',
        'value' => 1
      ]
    ],
    'website' => [
      'field_event_end' => [
        'type' => 'nested',
        'value' => [
          'bool' => [
            'must_not' => [
              'range' => [
                'field_event_end' => [
                  'lte' => 'now',
                  'format' => 'date_hour_minute_second'
                ]
              ]
            ]
          ]
        ]
      ],
      'mat_code' => [
        'type' => 'terms',
        'value' => ['page', 'story', 'pub_event', 'media']
      ]
    ],
    'community' => [
      'mat_code' => [
        'type' => 'terms',
        'value' => ['photo', 'issue', 'doc', 'article', 'media', 'advertisements']
      ]
    ]
  ];
  foreach ($defaults[$path_id] as $k => $d) {
    if (isset($_GET[$k])) {
      continue;
    } else {
      $es_query['body']['query']['function_score']['query']['bool']['filter'][] = ($d['type'] === 'nested' ? $d['value'] : [
        $d['type'] => [
          $k => $d['value']
        ]
      ]);
    }
  }
  return $es_query;
}
function applySort($es_query, $path_id)
{
  $defaults = [
    'catalog' => [],
    'website' => [
      'pub_event' => [
        'field_event_start' => [
          'order' => 'asc'
        ]
      ],
    ],
    'community' => []
  ];

  if (isset($_GET['sort'])) {
    $sort_parts = explode('~', $_GET['sort']);
    $sort_field = $sort_parts[0];

    // may need to enforce .keyword or do check logic like before
    $es_query['body']['sort'] = [
      $sort_field . '.keyword' => [
        'order' => (isset($sort_parts[1]) ? $sort_parts[1] : 'desc') // Default sort decending
      ]
    ];
  } elseif (isset($_GET['mat_code']) && isset($defaults[$path_id][$_GET['mat_code']])) {
    $es_query['body']['sort'] =  $defaults[$path_id][$_GET['mat_code']];
  }
  return $es_query;
}
function scaffoldQuery($queryable, $key, $value)
{
  switch ($queryable['type']) {
    case 'range':
      $dates = explode(',', $value);
      return [
        'range' => [
          $key => [
            'gte' => $dates[0],
            'lte' => $dates[1]
          ]
        ]
      ];
      break;
    case 'match':
      return [
        'match' => [
          $key => $value
        ]
      ];
      break;
    case 'term':
      return [
        'term' => [
          $key . (isset($queryable['keyword']) ? '' : '.keyword') => [
            'value' => $value
          ]
        ]
      ];
      break;
    case 'terms':
      return [
        'terms' => [
          $key . (isset($queryable['keyword']) ? '' : '.keyword')  => explode(',', $value)
        ]
      ];
      break;
  }
}
function arborelastic_theme($existing, $theme, $path)
{
  return [
    'search_results' => [
      'variables' => [
        'path_id' => NULL,
        'api_key' => NULL,
        'lists' => NULL,
        'results' => NULL,
        'facets' => NULL,
        'gridview' => NULL,
        'pager' => NULL
      ]
    ]
  ];
}
